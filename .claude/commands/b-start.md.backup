---
description: Master orchestrator that runs the full automated development pipeline continuously.
allowed-prompts:
  - tool: Bash
    prompt: run gh commands for GitHub operations
  - tool: Bash
    prompt: run git commands
  - tool: Bash
    prompt: run echo commands
---

Master orchestrator that runs the full automated development pipeline continuously using Claude Agent Teams.

## Usage
`/b-start`

## Project Configuration

Project settings are defined in `.claude/policy.md` under "Project Settings" section.

**IMPORTANT:** This orchestrator ONLY processes tickets from the GitHub Project defined in policy.md (Project 26 - AI Dev Request). Use `gh project item-list <PROJECT_ID> --owner <OWNER>` to fetch tickets.

**IMPORTANT:** Follow the **GitHub API Rate Limit Strategy** in `policy.md`. Use REST (`gh api`) for all issue/PR operations. Only use GraphQL (`gh project`) for project board operations which have no REST alternative. Never call `gh project field-list` or `gh project view` — use hardcoded IDs from policy.md.

## Prerequisites (MUST RUN FIRST)

**Before starting the pipeline, ensure the correct GitHub account is active:**

```bash
gh auth switch -u bradyoo12
```

**Available GitHub Accounts for Rate Limit Rotation:**
- `bradyoo12` (bradyoo12@outlook.com) - Primary account
- `byooxbert` (brad.yoo@xbert.io) - Secondary account for rate limit failover

## Rate Limit Management and Account Switching

**GitHub API has separate rate limits:**
- **REST API**: 5,000 requests/hour per account
- **GraphQL API**: 5,000 points/hour per account
- **Search API**: 30 requests/minute per account

**When to Check Rate Limits:**
- Before starting each cycle (Step 1)
- After any GraphQL operation (project board operations)
- When encountering 403/429 errors

**Rate Limit Check Command:**
```bash
# Check current rate limit status
gh api rate_limit --jq '{
  rest: .resources.core | "REST: \(.remaining)/\(.limit) (resets at \(.reset | strftime("%H:%M:%S")))",
  graphql: .resources.graphql | "GraphQL: \(.remaining)/\(.limit) (resets at \(.reset | strftime("%H:%M:%S")))",
  search: .resources.search | "Search: \(.remaining)/\(.limit) (resets at \(.reset | strftime("%H:%M:%S")))"
}'
```

**Account Switching Protocol:**

When any rate limit drops below 20% remaining OR hits 403/429 errors:

1. **Check which account is currently active:**
   ```bash
   CURRENT_USER=$(gh api user --jq '.login')
   echo "Current account: $CURRENT_USER"
   ```

2. **Switch to the alternate account:**
   ```bash
   if [ "$CURRENT_USER" = "bradyoo12" ]; then
     echo "Switching to secondary account (byooxbert)..."
     gh auth switch -u byooxbert
   else
     echo "Switching to primary account (bradyoo12)..."
     gh auth switch -u bradyoo12
   fi
   ```

3. **Verify the switch succeeded:**
   ```bash
   NEW_USER=$(gh api user --jq '.login')
   echo "Now using account: $NEW_USER"

   # Check new account's rate limits
   gh api rate_limit --jq '.resources.graphql | "GraphQL: \(.remaining)/\(.limit)"'
   ```

4. **If both accounts are rate-limited:**
   - Log: "Both accounts rate-limited. Waiting for reset..."
   - Check reset time for both accounts
   - Sleep until the earliest reset time (with 1-minute buffer)
   - Resume operation

**CRITICAL: Add rate limit checks at these steps:**
- **Step 1.5**: Check before fetching project board
- **Step 3a**: Check before claiming ticket (GraphQL operations)
- **Step 4**: Check before merging PR and moving status
- **Step 5c**: Check before moving ticket to Done
- **Step 6d/7c**: Check before creating multiple tickets

## Overview

This command orchestrates the entire development workflow using Agent Teams for parallelism within each ticket:

```
┌─────────────────────────────────────────────────────────────────┐
│                    b-start (Team Orchestrator)                    │
├─────────────────────────────────────────────────────────────────┤
│  1. Check policy.md, design.md, inventory.md, conventions.md       │
│  2. Audit all tickets for alignment                              │
│  3. b-ready team → plan, implement, unit tests, E2E test, PR      │
│  4. b-progress → merge PR to main, move to In Review             │
│  4b. GitHub Actions health check → find & fix CI failures        │
│  5. b-review team → parallel test + verify on staging            │
│  5e-ii. Doc maintenance → update inventory/design if changed     │
│  6. b-modernize team → parallel research + create suggestions    │
│  7. Site audit → visit live site, find errors, create tickets    │
│  8. Report status & loop back to step 1                          │
└─────────────────────────────────────────────────────────────────┘
```

### Agent Team Strategy

Teams are used within a single ticket to parallelize independent work:

| Step | Team Name | Agents | Why Parallel |
|------|-----------|--------|-------------|
| b-ready | `ready-<ticket#>` | planner + frontend-dev + backend-dev + unit-test-analyst + e2e-test-analyst + tester | Frontend & backend can be implemented simultaneously; unit tests created first, then E2E tests, then full test suite |
| b-progress | No team | Single operation | Simple merge, no parallelism needed |
| Actions check | No team | Single operation | Diagnose & fix CI failures sequentially |
| b-review | `review-<ticket#>` | test-runner + ai-verifier | E2E tests and AI verification run independently |
| b-modernize | `modernize` | tech-scout + competitor-scout | Independent web searches |
| site-audit | `site-audit` | error-checker + ux-reviewer | Error checking and UX review run independently |

**Rule: ONE ticket at a time.** Teams work collaboratively on the SAME ticket. Never process multiple tickets simultaneously.

### How to Wait for Agents (CRITICAL)

**When spawning agents, you MUST actually wait for results. Saying "waiting..." in text is NOT enough.**

**Method 1: Synchronous Spawning (RECOMMENDED)**
- Use Task tool WITHOUT `run_in_background` parameter
- The Task call blocks until the agent completes
- Results come back immediately as tool results
- Example:
  ```
  Task(subagent_type: "general-purpose", team_name: "ready-123", name: "planner", prompt: "...")
  <blocks here - no other work happens>
  <tool result appears with agent output>
  <now you can continue>
  ```

**Method 2: Parallel Synchronous Spawning**
- Spawn multiple agents in a SINGLE message with multiple Task calls
- All agents run simultaneously, but the message blocks until ALL complete
- Results come back as separate tool results
- Example:
  ```
  <single message with two Task calls>
  Task(name: "test-runner", ...)
  Task(name: "ai-verifier", ...)
  <blocks here until BOTH agents finish>
  <two tool results appear>
  <now you can continue>
  ```

**Method 3: Background Tasks (ONLY if you have other work to do)**
- Spawn with `run_in_background: true`
- Continue with other work
- Later, use `TaskOutput(task_id: <id>, block: true)` to retrieve results
- Example:
  ```
  Task(run_in_background: true, ...)
  <tool result has task_id and output_file>
  <do other work>
  TaskOutput(task_id: "...", block: true)
  <blocks here>
  <results appear>
  ```

**Method 4: Background + Polling with Timeout (RECOMMENDED for long-running tasks)**
- Use this for agents that might take 10+ minutes (planner, implementer, e2e-test-analyst)
- Spawn in background, then poll with non-blocking TaskOutput every 30-60 seconds
- Show progress updates to user so they know it's working
- Handle timeouts gracefully (mark ticket "on hold" and continue)
- Example:
  ```
  # Spawn in background
  Task(run_in_background: true, subagent_type: "general-purpose", name: "planner", prompt: "...")
  <tool result: task_id="abc-123", output_file="/path/to/output.txt">

  # Poll for completion with timeout
  max_wait = 20 minutes (1200 seconds)
  elapsed = 0
  poll_interval = 60 seconds

  while elapsed < max_wait:
    sleep 60
    TaskOutput(task_id: "abc-123", block: false, timeout: 5000)

    If task completed: break and process results
    If task still running:
      - Read last 10 lines from output_file with: tail -10 /path/to/output.txt
      - Log progress update to user: "Planner still working... (5 min elapsed)"
      - Continue polling

    elapsed += 60

  If timeout exceeded after 20 min:
    TaskStop(task_id: "abc-123")
    Mark ticket "on hold" with comment: "Planner timed out after 20 minutes"
    Continue to next ticket
  ```

**CRITICAL RULES:**
- ✅ **DO** use Task tool and wait for tool results before continuing
- ✅ **DO** spawn multiple agents in parallel when they can work independently
- ✅ **DO** use Method 4 (polling) for any agent that might take >5 minutes
- ✅ **DO** show progress updates every 60 seconds so the user knows it's working
- ✅ **DO** handle timeouts gracefully - don't wait forever
- ❌ **NEVER** say "waiting for agents..." and then continue in the same turn
- ❌ **NEVER** assume agents will "send messages when done" without blocking on Task or TaskOutput
- ❌ **NEVER** move to the next step until you have agent results in hand
- ❌ **NEVER** wait more than 20 minutes for a single agent - timeout and mark "on hold"

## Step 0: Worktree Setup (Multi-Instance Safe)

Each b-start instance MUST operate in its own dedicated git worktree so that multiple instances can run in parallel without conflicting on the same working directory.

**Why**: Two instances sharing the same checkout will corrupt each other's state when switching branches, pulling, or running builds.

### Setup Procedure

1. **Prune stale worktrees** from crashed previous instances:
   ```bash
   git worktree prune
   ```

2. **List existing worktrees** to find the next available worker number:
   ```bash
   git worktree list
   ```
   Look for entries matching `ai-dev-request-worker-N`. Pick the next available N (starting from 1).

3. **Create a new worktree** in detached HEAD state (avoids branch conflicts between worktrees):
   ```bash
   git fetch origin
   git worktree add --detach ../ai-dev-request-worker-<N>
   ```

4. **Record the worktree path** as `WORKTREE_DIR` (absolute path). **All subsequent file operations, git commands, and builds must run inside `WORKTREE_DIR`.**

5. **Install frontend dependencies** in the worktree:
   ```bash
   cd <WORKTREE_DIR>/platform/frontend && npm install
   ```

6. **Stale worktree cleanup on exit**: When the instance stops (Ctrl+C, error, or graceful shutdown), remove the worktree:
   ```bash
   git -C <MAIN_REPO_DIR> worktree remove <WORKTREE_DIR> --force
   ```
   If you forget, `git worktree prune` at the start of the next run will clean it up.

### Git Pattern for Worktrees

Since multiple worktrees cannot check out the same branch, **never check out the `main` branch**. Instead, use `origin/main` as a detached reference:

| Old Pattern | New Pattern (Worktree-Safe) |
|---|---|
| `git checkout main && git pull` | `git fetch origin && git checkout --detach origin/main` |
| `git checkout -b <branch>` | `git checkout -b <branch> origin/main` |

This pattern works in both regular repos and worktrees, so all agents and commands can use it unconditionally.

### Passing Worktree to Agents

**When spawning any agent** (via Task tool), always include in the prompt:

> Work in directory: `<WORKTREE_DIR>`. This is a git worktree. All file operations and git commands must happen in this directory. Never check out the `main` branch directly — use `git fetch origin && git checkout --detach origin/main` instead.

## Main Loop

**CRITICAL AUTONOMOUS OPERATION RULES:**
- ✅ **ALWAYS** proceed to the next cycle automatically after completing a cycle
- ✅ **ALWAYS** continue looping until the user presses Ctrl+C
- ✅ **When presenting "Next Steps", IMMEDIATELY execute the first step without asking**
- ✅ **When agents are working**, AUTOMATICALLY continue waiting for them to complete
- ❌ **NEVER** ask "Would you like me to continue?" or any variation
- ❌ **NEVER** ask "What would you prefer?" or offer options to stop/continue
- ❌ **NEVER** ask "Do you want me to continue? Or did you have a specific question?"
- ❌ **NEVER** wait for user confirmation to proceed to the next ticket
- ❌ **NEVER** say "Stop here" or suggest stopping
- ❌ **NEVER** ask what to do while waiting for agents (always choose option 1: continue waiting)

**The pipeline runs autonomously in an infinite loop. It does not require or request user permission to continue.**

**"Next Steps" Protocol:**
When you produce a "Next Steps" list (numbered or bulleted), you MUST immediately proceed with executing the first item. Do NOT present the list and then ask the user what to do. The "Next Steps" list is informational only - showing the user what you're about to do, not asking for permission.

**Agent Waiting Protocol:**
When agents are spawned and working on tasks:
- ✅ **AUTOMATICALLY** wait for agents to complete their work
- ✅ **AUTOMATICALLY** select option 1 (continue waiting) if any choice appears
- ❌ **NEVER** interrupt agent work to ask the user what to do
- ❌ **NEVER** offer options like "pause", "show output", or "stop" while agents are working
- The pipeline is fully autonomous - agents work until completion without user intervention

Execute this workflow in sequence, then loop:

### Step 1: Load Policy and Design Documents

Read and internalize the project guidelines. These are living documents that get updated after each completed ticket (see Step 5e).

1. **Read Policy** (`.claude/policy.md`):
   - Understand ticket management rules
   - Know when to add `on hold` label
   - Learn blocking scenarios
   - Understand code quality requirements

2. **Read Design** (`.claude/design.md`):
   - Understand overall architecture
   - Know system components
   - Understand data flow
   - Learn technology stack

3. **Read Inventory** (`.claude/inventory.md`):
   - Know what controllers, services, entities, pages already exist
   - Find existing code by domain before creating new files
   - Avoid creating duplicate features

4. **Read Conventions** (`.claude/conventions.md`):
   - Follow file placement rules
   - Use correct naming patterns
   - Apply standard coding patterns

5. **Read Infrastructure** (`.claude/infrastructure.md`):
   - Know deployment targets and URLs
   - Understand CI/CD pipeline
   - Know required environment variables

### Step 1.5: Fetch Project Board State (Once Per Cycle)

**CRITICAL RATE LIMIT OPTIMIZATION:** Use the project board cache to minimize GraphQL API calls. The cache stores project data for 5 minutes, reducing API calls from ~6 per cycle to ~0-1 per cycle.

1. **Check rate limits and switch accounts if needed:**
   ```bash
   echo "=== Rate Limit Check ==="
   GRAPHQL_REMAINING=$(gh api rate_limit --jq '.resources.graphql.remaining')
   GRAPHQL_LIMIT=$(gh api rate_limit --jq '.resources.graphql.limit')
   GRAPHQL_PERCENT=$((GRAPHQL_REMAINING * 100 / GRAPHQL_LIMIT))

   echo "GraphQL: $GRAPHQL_REMAINING/$GRAPHQL_LIMIT ($GRAPHQL_PERCENT%)"

   # Switch accounts if below 20% remaining
   if [ $GRAPHQL_PERCENT -lt 20 ]; then
     CURRENT_USER=$(gh api user --jq '.login')
     if [ "$CURRENT_USER" = "bradyoo12" ]; then
       echo "⚠️ Low rate limit ($GRAPHQL_PERCENT%) - switching to byooxbert account"
       gh auth switch -u byooxbert
     else
       echo "⚠️ Low rate limit ($GRAPHQL_PERCENT%) - switching to bradyoo12 account"
       gh auth switch -u bradyoo12
     fi
     # Verify new account has better limits
     NEW_REMAINING=$(gh api rate_limit --jq '.resources.graphql.remaining')
     echo "✓ Switched - new limit: $NEW_REMAINING"
   fi
   ```

2. **Check cache status and fetch project items** (uses cache if < 5 min old, otherwise fetches fresh):
   ```bash
   echo "=== Cache Status ==="
   bash .claude/scripts/gh-project-cache.sh status

   PROJECT_ITEMS=$(bash .claude/scripts/gh-project-cache.sh get)

   echo "=== GraphQL Rate Limit After Fetch ==="
   gh api rate_limit --jq '.resources.graphql | "Used: \(.used)/\(.limit) | Remaining: \(.remaining)"'
   ```

2. Use `echo "$PROJECT_ITEMS" | jq '...'` throughout the cycle instead of re-fetching.

3. Only force-refresh when necessary:
   - After claiming a ticket in Step 3a (to verify the claim succeeded)
   - Cache is automatically invalidated in Step 4 after status changes

### Step 2: Audit All Tickets for Alignment

Check all tickets in the project to ensure they align with policy and design:

1. **Check REST API rate limits** (audit may need REST API calls for issue details):
   ```bash
   REST_REMAINING=$(gh api rate_limit --jq '.resources.core.remaining')
   REST_PERCENT=$((REST_REMAINING * 100 / 5000))

   if [ $REST_PERCENT -lt 20 ]; then
     CURRENT_USER=$(gh api user --jq '.login')
     if [ "$CURRENT_USER" = "bradyoo12" ]; then
       echo "⚠️ Low REST API limit ($REST_PERCENT%) - switching to byooxbert"
       gh auth switch -u byooxbert
     else
       echo "⚠️ Low REST API limit ($REST_PERCENT%) - switching to bradyoo12"
       gh auth switch -u bradyoo12
     fi
     echo "✓ Switched accounts for Step 2 audit"
   fi
   ```

2. Use the cached project items from Step 1.5:
   ```bash
   # Use $PROJECT_ITEMS instead of re-fetching
   echo "$PROJECT_ITEMS" | jq '...'
   ```

3. For each ticket in the project (filter by `type: "Issue"`):
   - Analyze if the ticket aligns with `.claude/policy.md` rules
   - Analyze if the ticket aligns with `.claude/design.md` architecture
   - Check for conflicts or inconsistencies

4. **If a ticket is OUT OF ALIGNMENT, classify the block:**

   **Hard Block** (needs human action) → add `on hold` label:
   - Security concerns, production-critical changes, unclear requirements, repeated test failures
   - Add `on hold` label (REST):
     ```bash
     gh api --method POST "repos/bradyoo12/ai-dev-request/issues/<issue_number>/labels" -f "labels[]=on hold"
     ```
   - Add a comment explaining the concern

   **Soft Block** (prerequisites not yet met) → skip WITHOUT labeling:
   - Prerequisite PRs not yet merged, dependent tickets incomplete, blocked by in-progress work
   - Do NOT add `on hold` label — just skip the ticket this cycle
   - Log: "Skipping #<number>: <reason> — will retry next cycle"

5. Log summary of audit results

### Step 3: b-ready — Implement with Agent Team

Implement and locally test ONE Ready ticket using an Agent Team.

#### Step 3a: Claim the Ticket (RACE-CONDITION SAFE)

**CRITICAL: Multiple b-start instances may run on different machines. The status change MUST happen BEFORE any other work on the ticket to prevent duplicate processing.**

1. Use the cached project board from Step 1.5:
   ```bash
   # Use $PROJECT_ITEMS instead of re-fetching
   echo "$PROJECT_ITEMS" | jq '...'
   ```
2. Filter for issues with "Ready" status and no `on hold` label
3. If no ticket found, skip to Step 4. **If Steps 3–5 all find no tickets to process** (no Ready, no In Progress with PRs, no In Review), **jump directly to Step 6 (b-modernize)** to use idle time productively researching technologies and competitors.
4. **Check GraphQL rate limit before claiming** (claiming uses GraphQL):
   ```bash
   GRAPHQL_REMAINING=$(gh api rate_limit --jq '.resources.graphql.remaining')
   GRAPHQL_PERCENT=$((GRAPHQL_REMAINING * 100 / 5000))

   if [ $GRAPHQL_PERCENT -lt 20 ]; then
     CURRENT_USER=$(gh api user --jq '.login')
     [ "$CURRENT_USER" = "bradyoo12" ] && gh auth switch -u byooxbert || gh auth switch -u bradyoo12
     echo "✓ Switched accounts before claiming ticket"
   fi
   ```
5. **IMMEDIATELY move the ticket to "In Progress"** — this is the FIRST action, before reading the ticket, classifying it, or doing anything else:
   ```bash
   gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id <item_id> --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 47fc9ee4
   gh api graphql -f query='mutation { updateProjectV2ItemPosition(input: { projectId: "PVT_kwHNf9fOATn4hA", itemId: "<item_id>" }) { item { id } } }'
   ```
6. **Verify the claim succeeded** — force-refresh the cache to get the latest state:
   ```bash
   PROJECT_ITEMS=$(bash .claude/scripts/gh-project-cache.sh get true)
   ```
   - If the ticket is already "In Progress" (claimed by another instance between your fetch and your edit), **skip this ticket** and go back to step 1 to find the next Ready ticket.
7. Log: "Claimed ticket #<number> — moved to In Progress"

**Do NOT read the ticket details, classify scope, or create teams until the claim is confirmed.**

#### Step 3b: Read and Classify the Ticket

1. Fetch the issue details (REST):
   ```bash
   gh api "repos/bradyoo12/ai-dev-request/issues/<issue_number>"
   ```
2. Classify the ticket scope:
   - **Full-stack**: Needs both frontend AND backend changes → use team
   - **Single-scope**: Only frontend OR only backend → use single agent
   - **Simple**: Config, docs, small fix → do directly (no team)

#### Step 3c: Create Team and Execute

**For full-stack tickets — create a team:**

1. Create the team:
   ```
   TeamCreate: ready-<ticket_number>
   ```

2. Create tasks in the team's task list using TaskCreate:
   - Task: "Analyze ticket and create implementation plan"
   - Task: "Create feature branch from main"
   - Task: "Implement frontend changes"
   - Task: "Implement backend changes"
   - Task: "Analyze new code for unit test gaps and create missing unit tests"
   - Task: "Run full test suite"
   - Task: "Commit, push, and create PR"

3. **Spawn planner with timeout polling** (use Method 4 - Background + Polling):

   a. Spawn in background:
   ```bash
   Task(run_in_background: true, subagent_type: "general-purpose", team_name: "ready-<ticket_number>", name: "planner", prompt: "Work in directory: <WORKTREE_DIR>. Read ticket #<number>, policy.md, design.md. Create implementation plan, post as comment, create branch, implement ALL changes (frontend + backend), commit all work.")
   ```
   - The Task tool returns immediately with task_id and output_file

   b. Poll for completion with progress updates (max 20 minutes):
   ```bash
   # Track elapsed time
   START_TIME=$(date +%s)
   MAX_WAIT=1200  # 20 minutes in seconds
   POLL_INTERVAL=60  # Check every 60 seconds

   while true; do
     ELAPSED=$(($(date +%s) - START_TIME))

     # Check if timed out
     if [ $ELAPSED -ge $MAX_WAIT ]; then
       echo "⏱️ Planner timed out after 20 minutes - marking ticket on hold"
       TaskStop(task_id: <task_id>)
       # Add "on hold" label and comment
       gh api --method POST "repos/bradyoo12/ai-dev-request/issues/<issue_number>/labels" -f "labels[]=on hold"
       gh api --method POST "repos/bradyoo12/ai-dev-request/issues/<issue_number>/comments" -f body="Planner agent timed out after 20 minutes. Needs investigation."
       break
     fi

     # Poll for completion (non-blocking)
     RESULT=$(TaskOutput(task_id: <task_id>, block: false, timeout: 5000))

     if [ task completed ]; then
       echo "✅ Planner completed successfully after $(($ELAPSED / 60)) minutes"
       # Process results and continue to step 4
       break
     else
       # Show progress update
       MINUTES=$(($ELAPSED / 60))
       echo "⏳ Planner still working... ($MINUTES min elapsed)"

       # Show last few lines of output for visibility
       tail -10 <output_file>

       # Wait before next poll
       sleep $POLL_INTERVAL
     fi
   done
   ```

   c. What planner does (if it completes):
   - Reads the ticket, policy.md, and design.md
   - Creates a detailed implementation plan
   - Posts the plan as a comment on the issue
   - Creates the feature branch: `<ticket_number>-<slug>`
   - Implements ALL changes directly (frontend AND backend)
   - Commits all work
   - Reports completion with summary

4. **After planner completes, spawn unit-test-analyst and wait** (use synchronous Task):
   ```
   Task(subagent_type: "general-purpose", team_name: "ready-<ticket_number>", name: "unit-test-analyst", prompt: "...")
   ```
   - Identifies all files added or modified by the current ticket (diff against main)
   - For each modified/new file, checks if corresponding unit test files exist:
     - Frontend: `*.test.ts` / `*.test.tsx` alongside or in `__tests__/` directories
     - Backend: `*Tests.cs` in the test project
   - Analyzes the new code for logic that should be covered by unit tests rather than E2E tests:
     - Utility functions, helpers, and pure logic
     - State management (Zustand stores, reducers)
     - Data transformations and formatting
     - Validation logic
     - API response parsing / error handling
     - Custom hooks with testable behavior
     - Backend service methods, validators, and business logic
   - Creates missing unit tests following existing test patterns in the codebase
   - Runs unit tests to verify they pass:
     - Frontend: `npx vitest run` (or `npm test -- --watchAll=false`)
     - Backend: `dotnet test`
   - If new tests fail, fixes them (up to 3 attempts)
   - Reports results: how many tests added, coverage summary
   - **WAIT**: Task tool blocks here until unit-test-analyst completes and returns results

5. **After unit-test-analyst completes, spawn e2e-test-analyst with timeout polling** (use Method 4):

   a. Spawn in background (E2E test creation can take 10+ minutes):
   ```bash
   Task(run_in_background: true, subagent_type: "general-purpose", team_name: "ready-<ticket_number>", name: "e2e-test-analyst", prompt: "Analyze new user-facing features, create/update Playwright E2E tests, run tests, fix failures up to 3 attempts.")
   ```

   b. Poll for completion with progress updates (max 15 minutes):
   ```bash
   # Similar polling pattern as planner
   START_TIME=$(date +%s)
   MAX_WAIT=900  # 15 minutes

   while true; do
     ELAPSED=$(($(date +%s) - START_TIME))
     if [ $ELAPSED -ge $MAX_WAIT ]; then
       echo "⏱️ E2E test analyst timed out - continuing without E2E tests"
       TaskStop(task_id: <task_id>)
       echo "⚠️ WARNING: No E2E tests created for this ticket (timeout)"
       break
     fi

     RESULT=$(TaskOutput(task_id: <task_id>, block: false, timeout: 5000))
     if [ task completed ]; then
       echo "✅ E2E test analyst completed"
       break
     fi

     echo "⏳ Creating E2E tests... ($(($ELAPSED / 60)) min)"
     tail -5 <output_file>
     sleep 60
   done
   ```

   c. What e2e-test-analyst does (if it completes):
   - Identifies new user-facing features added by the current ticket:
     - New pages and routes
     - New forms with submission workflows
     - Navigation changes
     - Critical user workflows (multi-step processes)
     - API integrations visible to users
   - For each new feature, checks if Playwright E2E tests exist in `platform/frontend/e2e/`
   - Analyzes what should be covered by E2E tests (focus on critical user paths, not every component):
     - New pages → test navigation and rendering
     - Forms → test submission, validation, and success/error states
     - User workflows → test end-to-end journey
     - API integration → test user action → network request → UI update
     - Accessibility features → test keyboard navigation, ARIA labels
     - i18n/localization → test new UI strings in both en and ko
   - Creates or updates Playwright tests following existing patterns in `platform/frontend/e2e/`
   - Runs E2E tests to verify they pass: `npm test` in platform/frontend
   - If new tests fail, fixes them (up to 3 attempts)
   - Reports results: how many tests added/updated

6. **After e2e-test-analyst completes, spawn tester and wait** (use synchronous Task):
   ```
   Task(subagent_type: "general-purpose", team_name: "ready-<ticket_number>", name: "tester", prompt: "...")
   ```
   - Runs `npm run build` in platform/frontend
   - Runs full Playwright E2E suite: `npm test` in platform/frontend
   - Reports results
   - If tests fail: attempt fixes (up to 3 attempts), then report
   - **WAIT**: Task tool blocks here until tester completes and returns results

7. **After tester completes, spawn final-committer and wait** (use synchronous Task):
   ```
   Task(subagent_type: "general-purpose", team_name: "ready-<ticket_number>", name: "final-committer", prompt: "...")
   ```
   - Commits all changes (including new unit tests and E2E tests) with "Refs #<ticket_number>"
   - Pushes branch and creates PR
   - Reports success/failure
   - **WAIT**: Task tool blocks here until final-committer completes and returns results

8. **After final-committer completes, shut down all agents and delete the team:**
   ```
   SendMessage: shutdown_request to each agent (wait for shutdown_response from each)
   TeamDelete
   ```

**For single-scope or simple tickets — use single Task agent with polling:**

Spawn a single general-purpose agent via Task tool (no team needed):

a. Spawn in background:
```bash
Task(run_in_background: true, subagent_type: "general-purpose", name: "implementer", prompt: "Work in directory: <WORKTREE_DIR>. Implement ticket #<number>: read ticket, create plan, create branch, implement changes, run tests, commit, push, create PR.")
```

b. Poll for completion (max 20 minutes):
```bash
START_TIME=$(date +%s)
MAX_WAIT=1200

while true; do
  ELAPSED=$(($(date +%s) - START_TIME))
  if [ $ELAPSED -ge $MAX_WAIT ]; then
    echo "⏱️ Implementer timed out after 20 minutes - marking ticket on hold"
    TaskStop(task_id: <task_id>)
    # Add "on hold" label
    gh api --method POST "repos/bradyoo12/ai-dev-request/issues/<issue_number>/labels" -f "labels[]=on hold"
    gh api --method POST "repos/bradyoo12/ai-dev-request/issues/<issue_number>/comments" -f body="Implementation timed out after 20 minutes."
    break
  fi

  RESULT=$(TaskOutput(task_id: <task_id>, block: false, timeout: 5000))
  if [ task completed ]; then
    echo "✅ Implementer completed successfully"
    break
  fi

  echo "⏳ Implementing... ($(($ELAPSED / 60)) min)"
  tail -5 <output_file>
  sleep 60
done
```

c. What implementer does:
- Read ticket, create plan, create branch
- Implement changes
- Run tests
- Commit, push, create PR
- This follows the same workflow as `.claude/agents/b-ready.md`

#### Step 3d: Handle Failures

If the team fails or gets stuck:
1. Shut down all agents in the team
2. Delete the team
3. Add `on hold` label to the ticket
4. Add a comment explaining the failure
5. Return to latest main: `git fetch origin && git checkout --detach origin/main`, delete the branch
6. Proceed to Step 4

### Step 4: b-progress — Merge PR (No Team)

Merge PRs to main. This is a simple operation — no team needed.

1. **Check rate limits** (Step 4 uses both REST and GraphQL):
   ```bash
   REST_REMAINING=$(gh api rate_limit --jq '.resources.core.remaining')
   GRAPHQL_REMAINING=$(gh api rate_limit --jq '.resources.graphql.remaining')
   REST_PERCENT=$((REST_REMAINING * 100 / 5000))
   GRAPHQL_PERCENT=$((GRAPHQL_REMAINING * 100 / 5000))

   if [ $REST_PERCENT -lt 20 ] || [ $GRAPHQL_PERCENT -lt 20 ]; then
     CURRENT_USER=$(gh api user --jq '.login')
     [ "$CURRENT_USER" = "bradyoo12" ] && gh auth switch -u byooxbert || gh auth switch -u bradyoo12
     echo "✓ Switched accounts for Step 4 (merge PR + status change)"
   fi
   ```

2. Log "Starting b-progress..."
3. Find "In Progress" tickets with open PRs (no `on hold` label):
   ```bash
   # Use cached $PROJECT_ITEMS for project board state
   echo "$PROJECT_ITEMS" | jq '...'
   # Only fetch PRs from REST API (separate rate limit)
   gh api "repos/bradyoo12/ai-dev-request/pulls?state=open&per_page=100" --jq '[.[] | {number, headRefName: .head.ref, url: .html_url}]'
   ```
4. Verify PR is mergeable (REST):
   ```bash
   gh api "repos/bradyoo12/ai-dev-request/pulls/<pr_number>" --jq '{mergeable, mergeable_state}'
   ```
5. Merge (REST):
   ```bash
   gh api --method PUT "repos/bradyoo12/ai-dev-request/pulls/<pr_number>/merge" -f merge_method=merge
   gh api --method DELETE "repos/bradyoo12/ai-dev-request/git/refs/heads/<branch_name>"
   ```
6. Move ticket to "In Review":
   ```bash
   gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id <item_id> --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id df73e18b
   gh api graphql -f query='mutation { updateProjectV2ItemPosition(input: { projectId: "PVT_kwHNf9fOATn4hA", itemId: "<item_id>" }) { item { id } } }'
   ```
7. **Invalidate the cache** so Step 5 gets fresh data:
   ```bash
   bash .claude/scripts/gh-project-cache.sh invalidate
   ```
8. **Add a detailed "How to Test" comment** with staging URL and step-by-step instructions
9. Cleanup (worktree-safe — never checks out `main` branch):
   ```bash
   git fetch origin && git checkout --detach origin/main
   ```
10. **Delete stale branches** (local and remote) that have been fully merged:
   ```bash
   # Delete merged local branches (never delete main/master)
   git branch --merged origin/main | grep -vE '^\*|main|master' | xargs -r git branch -d
   # Delete merged remote branches (never delete main/master)
   git branch -r --merged origin/main | grep -vE 'main|master' | sed 's/origin\///' | xargs -r -I {} git push origin --delete {}
   ```

### Step 4b: GitHub Actions Health Check

After merging PRs, check GitHub Actions for failed workflow runs on `main` and create tickets for any failures found.

**IMPORTANT: Use the /create-ticket skill to create tickets for build/deploy failures. Do NOT attempt to fix them inline.**

#### Step 4b-1: Check Recent Workflow Runs

1. Fetch recent workflow runs on the `main` branch:
   ```bash
   gh run list --repo bradyoo12/ai-dev-request --branch main --limit 10 --json databaseId,status,conclusion,name,headBranch,event,createdAt,headSha,displayTitle
   ```

2. Also check for failed runs on any branch (catches PR check failures):
   ```bash
   gh run list --repo bradyoo12/ai-dev-request --status failure --limit 5 --json databaseId,status,conclusion,name,headBranch,event,createdAt,headSha,displayTitle
   ```

3. If no failures found, log "GitHub Actions: all green" and skip to Step 5.

#### Step 4b-2: Diagnose and Create Tickets for Failures

For each failed run:

1. Get the failure details and logs:
   ```bash
   gh run view <run_id> --repo bradyoo12/ai-dev-request --log-failed
   ```

2. If logs are too large, get job-level details first:
   ```bash
   gh run view <run_id> --repo bradyoo12/ai-dev-request --json jobs --jq '.jobs[] | select(.conclusion=="failure") | {name, conclusion, steps: [.steps[] | select(.conclusion=="failure") | {name, conclusion}]}'
   ```

3. Classify the failure:

   **Transient failure** (network timeout, rate limit, flaky test, GitHub infrastructure issue):
   - Re-run the failed jobs:
     ```bash
     gh run rerun <run_id> --repo bradyoo12/ai-dev-request --failed
     ```
   - Log: "Re-ran transient failure in run #<run_id>"
   - Move to the next failed run

   **Code/config failure** (build error, test failure, lint error, deployment config issue):
   - Proceed to Step 4b-3

#### Step 4b-3: Classify and Fix Code/Config Failures

1. **Determine if the failure is related to the just-merged PR:**

   a. Get the failed run details:
      ```bash
      FAILED_RUN_SHA=$(gh run view <run_id> --repo bradyoo12/ai-dev-request --json headSha --jq '.headSha')
      ```

   b. Check if this commit was part of a recently merged PR:
      ```bash
      RELATED_PR=$(gh api "search/issues?q=repo:bradyoo12/ai-dev-request+is:pr+is:merged+sha:$FAILED_RUN_SHA&per_page=1" --jq '.items[0].number')
      ```

   c. If `RELATED_PR` is found and it was merged in the last 30 minutes, this is a **same-ticket failure** (the PR broke the build). Otherwise, it's an **unrelated failure**.

2. Analyze the error logs and classify the failure type:

   **Quick Fix (fix immediately):**
   - Lint/format violations (prettier, eslint)
   - Simple type errors (missing imports, typos)
   - Outdated snapshots
   - Missing semicolons or trivial syntax issues
   - Wrong file paths in configs
   - Missing references or dependencies
   - Clear one-line fixes

   **Needs Investigation (reopen ticket or create new one):**
   - Test failures with unclear root cause
   - Complex build errors affecting multiple files
   - Race conditions or flaky tests
   - Deployment/infrastructure issues
   - Database migration failures
   - Environment-specific bugs
   - Anything requiring >15 minutes of analysis

3. **If QUICK FIX + SAME-TICKET FAILURE:**

   a. Create a fix branch (worktree-safe):
      ```bash
      git fetch origin
      git checkout -b fix/ci-<run_id> origin/main
      ```

   b. Fix the issue in the worktree

   c. Run the relevant checks locally to verify the fix:
      - Build: `cd platform/frontend && npm run build`
      - Tests: `cd platform/frontend && npm test`
      - Backend: `cd platform/backend/AiDevRequest.API && dotnet build`

   d. Commit and push (reference the original ticket):
      ```bash
      git add -A
      git commit -m "fix: resolve CI failure from Actions run #<run_id>

Refs #<RELATED_PR ticket number>

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
      git push origin fix/ci-<run_id>
      ```

   e. Create a PR and merge immediately:
      ```bash
      gh pr create --repo bradyoo12/ai-dev-request --title "fix: CI failure from #<RELATED_PR ticket number>" --body "Fixes CI failure from GitHub Actions run #<run_id> caused by PR #<RELATED_PR>.\n\n**Root cause:** <description>\n**Fix:** <what was changed>\n\nRefs #<RELATED_PR ticket number>"
      # Wait for PR number
      gh pr merge <pr_number> --merge --delete-branch
      ```

   f. Add a comment to the original ticket explaining the fix:
      ```bash
      gh api --method POST "repos/bradyoo12/ai-dev-request/issues/<RELATED_PR ticket number>/comments" -f body="✅ **CI Failure Fixed**\n\nGitHub Actions run #<run_id> failed after merging this PR.\n\n**Root cause:** <description>\n**Fix:** <what was changed>\n**Fix PR:** #<fix_pr_number>\n\nThe fix has been merged and CI is now passing."
      ```

   g. Return to worktree main and verify:
      ```bash
      git fetch origin && git checkout --detach origin/main
      sleep 30
      gh run list --repo bradyoo12/ai-dev-request --branch main --limit 3 --json databaseId,status,conclusion,name
      ```

   h. Log: "Fixed CI failure #<run_id> as part of ticket #<RELATED_PR ticket number>"

4. **If QUICK FIX + UNRELATED FAILURE:**

   a. Create a fix branch (worktree-safe):
      ```bash
      git fetch origin
      git checkout -b fix/ci-<run_id> origin/main
      ```

   b. Fix the issue in the worktree

   c. Run the relevant checks locally to verify the fix

   d. Commit and push:
      ```bash
      git add -A
      git commit -m "fix: resolve CI failure from Actions run #<run_id>

Co-Authored-By: Claude Sonnet 4.5 <noreply@anthropic.com>"
      git push origin fix/ci-<run_id>
      ```

   e. Create a PR and merge immediately:
      ```bash
      gh pr create --repo bradyoo12/ai-dev-request --title "[CI Fix] <short description of failure>" --body "Fixes CI failure from GitHub Actions run #<run_id>.\n\n**Root cause:** <description>\n**Fix:** <what was changed>"
      # Wait for PR number
      gh pr merge <pr_number> --merge --delete-branch
      ```

   f. Return to worktree main and verify

   g. Log: "Fixed unrelated CI failure #<run_id> immediately"

5. **If NEEDS INVESTIGATION + SAME-TICKET FAILURE:**

   a. Reopen the original ticket:
      ```bash
      gh api --method PATCH "repos/bradyoo12/ai-dev-request/issues/<RELATED_PR ticket number>" -f state=open
      ```

   b. Move the ticket back to "In Progress" and add "on hold" label:
      ```bash
      gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id <item_id> --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 47fc9ee4
      gh api --method POST "repos/bradyoo12/ai-dev-request/issues/<RELATED_PR ticket number>/labels" -f "labels[]=on hold"
      ```

   c. Add a detailed comment explaining the failure:
      ```bash
      gh api --method POST "repos/bradyoo12/ai-dev-request/issues/<RELATED_PR ticket number>/comments" -f body="⚠️ **CI Failure After Merge**\n\nGitHub Actions run #<run_id> failed after merging this PR.\n\n**Workflow:** <workflow_name>\n**Error Summary:**\n\`\`\`\n<error_log_excerpt>\n\`\`\`\n\n**Logs:** https://github.com/bradyoo12/ai-dev-request/actions/runs/<run_id>\n\n**Classification:** Needs investigation due to <reason>\n\nThis ticket has been reopened and marked 'on hold' for investigation."
      ```

   d. Invalidate cache and log:
      ```bash
      bash .claude/scripts/gh-project-cache.sh invalidate
      echo "Reopened ticket #<RELATED_PR ticket number> due to CI failure requiring investigation"
      ```

   e. Proceed to Step 5

6. **If NEEDS INVESTIGATION + UNRELATED FAILURE:**

   a. Create a detailed investigation ticket (REST):
      ```bash
      gh api --method POST "repos/bradyoo12/ai-dev-request/issues" \
        -f title="[CI] Investigate failure in <workflow_name>" \
        -f body="GitHub Actions run #<run_id> failed on \`main\` branch.\n\n**Workflow:** <workflow_name>\n**Branch:** <branch>\n**Error Summary:**\n\`\`\`\n<error_log_excerpt>\n\`\`\`\n\n**Reproduction:** Logs available at https://github.com/bradyoo12/ai-dev-request/actions/runs/<run_id>\n\n**Classification:** Needs investigation due to <reason>\n\n**Next Steps:**\n1. Analyze root cause\n2. Determine fix approach\n3. Implement and test fix\n4. Verify CI passes" \
        -f "labels[]=bug" \
        -f "labels[]=ci"
      ```

   b. Add the ticket to the project and set to **Ready** (with error handling):
      ```bash
      # Add to project
      ITEM_ID=$(gh project item-add 26 --owner bradyoo12 --url <issue_url> --format json --jq '.id')

      if [ -z "$ITEM_ID" ]; then
        echo "❌ ERROR: Failed to add issue to project board"
      else
        echo "✓ Added issue to project (Item ID: $ITEM_ID)"

        # Set status to Ready with error handling
        if ! gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id "$ITEM_ID" \
             --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 61e4505c 2>&1; then

          # Failed - check if rate limited
          CURRENT_USER=$(gh api user --jq '.login' 2>/dev/null)
          echo "❌ ERROR: Failed to set status to Ready for Item $ITEM_ID (account: $CURRENT_USER)"
          echo "   Attempting to switch accounts and retry..."

          # Switch accounts
          if [ "$CURRENT_USER" = "bradyoo12" ]; then
            gh auth switch -u byooxbert 2>/dev/null && echo "   Switched to byooxbert"
          else
            gh auth switch -u bradyoo12 2>/dev/null && echo "   Switched to bradyoo12"
          fi

          # Retry once
          if gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id "$ITEM_ID" \
               --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 61e4505c 2>&1; then
            echo "   ✓ Retry succeeded - status set to Ready"
          else
            echo "   ❌ Retry also failed - ticket will have 'No Status'"
            echo "   Manual fix needed: gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id $ITEM_ID --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 61e4505c"
          fi
        else
          echo "✓ Status set to Ready"

          # Move to top (best-effort, don't fail if this errors)
          gh api graphql -f query="mutation { updateProjectV2ItemPosition(input: { projectId: \"PVT_kwHNf9fOATn4hA\", itemId: \"$ITEM_ID\" }) { item { id } } }" 2>/dev/null && echo "✓ Moved to top of column" || echo "⚠️ Could not move to top"
        fi
      fi
      ```

   c. Log: "Created investigation ticket for CI failure #<run_id> - ticket #<issue_number>"

   d. Proceed to Step 5 (this ticket will be picked up in the next cycle)

### Step 5: b-review — Verify with Agent Team

Verify changes on staging using parallel agents.

#### Step 5a: Find Eligible Ticket

1. Fetch the project board (cache was invalidated in Step 4, so this will get fresh data):
   ```bash
   PROJECT_ITEMS=$(bash .claude/scripts/gh-project-cache.sh get)
   ```
2. Filter for "In Review" tickets without `on hold` label:
   ```bash
   echo "$PROJECT_ITEMS" | jq '...'
   ```
3. If none found, skip to Step 6

#### Step 5b: Create Review Team

1. Create the team:
   ```
   TeamCreate: review-<ticket_number>
   ```

2. Pull latest and install deps (worktree-safe):
   ```bash
   git fetch origin && git checkout --detach origin/main
   cd platform/frontend && npm install
   ```

3. **Spawn BOTH agents in parallel and wait** (use parallel synchronous Task - see "How to Wait for Agents" above):

   In a SINGLE message, spawn both agents with two Task calls:
   ```
   Task(subagent_type: "general-purpose", team_name: "review-<ticket_number>", name: "test-runner", prompt: "...")
   Task(subagent_type: "general-purpose", team_name: "review-<ticket_number>", name: "ai-verifier", prompt: "...")
   ```

   **test-runner** agent:
   - Installs Playwright: `npx playwright install chromium`
   - Runs FULL Playwright E2E suite against staging: `npm run test:staging`
   - Reports pass/fail results with details

   **ai-verifier** agent:
   - Reads the ticket requirements
   - Reads the "How to Test" comment
   - Uses WebFetch to verify staging URL is accessible
   - Performs AI-simulated human testing
   - Checks for console errors, performance, visual correctness
   - Reports verification results

   **WAIT**: Both Task calls execute in parallel. The message blocks until BOTH agents complete. You will receive TWO tool results (one from each agent).

#### Step 5c: Handle Results

**If BOTH pass:**
- Move to "Done":
  ```bash
  gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id <item_id> --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 98236657
  gh api graphql -f query='mutation { updateProjectV2ItemPosition(input: { projectId: "PVT_kwHNf9fOATn4hA", itemId: "<item_id>" }) { item { id } } }'
  ```
- Invalidate cache after status change:
  ```bash
  bash .claude/scripts/gh-project-cache.sh invalidate
  ```
- Close the issue (REST):
  ```bash
  gh api --method PATCH "repos/bradyoo12/ai-dev-request/issues/<issue_number>" -f state=closed -f state_reason=completed
  ```
- Add completion comment
- **Update policy.md and design.md** to reflect the completed changes (see Step 5e)

**If EITHER fails:**
- Add failure comment with details from both agents
- Add `on hold` label (REST):
  ```bash
  gh api --method POST "repos/bradyoo12/ai-dev-request/issues/<issue_number>/labels" -f "labels[]=on hold"
  ```
- Invalidate cache after label change:
  ```bash
  bash .claude/scripts/gh-project-cache.sh invalidate
  ```

#### Step 5d: Cleanup

Shut down all agents, delete the team.

#### Step 5e: Update Policy and Design Documents

**Only runs when a ticket was moved to Done in Step 5c.**

After a ticket is verified and completed, update the project documentation to reflect the changes:

1. **Read the completed ticket** (REST):
   ```bash
   gh api "repos/bradyoo12/ai-dev-request/issues/<issue_number>"
   ```

2. **Read the merged PR** (REST — uses search rate limit, not GraphQL):
   ```bash
   gh api "search/issues?q=repo:bradyoo12/ai-dev-request+is:pr+is:merged+<issue_number>&per_page=5" --jq '.items[] | {number, title, body}'
   # For changed files per PR:
   gh api "repos/bradyoo12/ai-dev-request/pulls/<pr_number>/files" --jq '[.[] | .filename]'
   ```

3. **Update `.claude/inventory.md`** if the ticket introduced:
   - New controllers, services, or entities → add under the appropriate domain section
   - New frontend pages or components → add under the appropriate feature area
   - New API modules → add with backend controller mapping
   - Removed or renamed files → update or remove entries

4. **Update `.claude/design.md`** if the ticket introduced:
   - New API endpoints or backend services with significant functionality
   - New database tables or schema changes
   - Changes to the architecture or data flow
   - New integrations or third-party services
   - Updated tech stack or dependencies

5. **Update `.claude/conventions.md`** if the ticket introduced:
   - New coding patterns or conventions
   - Changes to file placement rules
   - New testing patterns

6. **Update `.claude/infrastructure.md`** if the ticket introduced:
   - New environment variables or configuration
   - Changes to CI/CD pipeline or deployment
   - New Azure resources or Docker changes

7. **Update `.claude/policy.md`** if the ticket introduced:
   - New development rules or conventions
   - Changes to the build/test/deploy process
   - Updated quality standards or review criteria
   - New labels, workflows, or ticket management changes

8. **How to update:**
   - Read the current file
   - Identify the relevant section(s) to update
   - Make minimal, targeted edits — only add/change what the completed ticket affects
   - Do NOT remove existing content unless it is now incorrect
   - Do NOT rewrite entire sections — surgical updates only

9. **Commit and push the documentation updates** (worktree-safe — push to main without checking it out):
   ```bash
   git add .claude/inventory.md .claude/design.md .claude/conventions.md .claude/infrastructure.md .claude/policy.md
   git commit -m "docs: update .claude/ docs after completing #<issue_number>"
   git push origin HEAD:main
   ```

10. If no files need updating (e.g., the ticket was a minor bug fix with no impact), skip this step and log: "No doc updates needed for #<issue_number>"

### Step 6: b-modernize — Research with Agent Team

Search for recent technologies and create suggestion tickets using parallel researchers.

**This step also runs as an idle fallback:** If Steps 3–5 all found no tickets to process (no Ready tickets, no In Progress PRs to merge, no In Review tickets to verify), b-modernize runs automatically so the pipeline stays productive instead of looping empty cycles.

#### Step 6a: Playwright UI Smoke Test (Idle Pre-check)

Before researching new technologies, use Playwright to test all links and buttons on the live UI to catch any errors or unexpected results.

1. Pull latest and install deps (worktree-safe):
   ```bash
   git fetch origin && git checkout --detach origin/main
   cd platform/frontend && npm install
   npx playwright install chromium
   ```

2. Run a Playwright smoke test that:
   - Navigates to every discoverable page/route on the staging site
   - Clicks all links and verifies they navigate correctly (no 404s, no broken routes)
   - Clicks all buttons and checks for JavaScript errors, uncaught exceptions, or unexpected UI states
   - Checks the browser console for any error-level messages
   - Verifies no network requests return 4xx/5xx responses

3. For each issue found:
   - Create a ticket with a clear title and reproduction steps (REST):
     ```bash
     gh api --method POST "repos/bradyoo12/ai-dev-request/issues" -f title="[UI Bug] {description}" -f body="{detailed reproduction steps and error details}" -f "labels[]=bug"
     ```
   - Add the ticket to the project and set status to **Ready** (with error handling):
     ```bash
     # Add to project
     ITEM_ID=$(gh project item-add 26 --owner bradyoo12 --url {issue_url} --format json --jq '.id')

     if [ -z "$ITEM_ID" ]; then
       echo "❌ ERROR: Failed to add UI bug issue to project board"
     else
       # Set status to Ready with error handling
       if ! gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id "$ITEM_ID" \
            --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 61e4505c 2>&1; then

         # Failed - try switching accounts
         CURRENT_USER=$(gh api user --jq '.login' 2>/dev/null)
         echo "❌ Failed to set status (account: $CURRENT_USER), retrying..."

         [ "$CURRENT_USER" = "bradyoo12" ] && gh auth switch -u byooxbert || gh auth switch -u bradyoo12

         # Retry
         gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id "$ITEM_ID" \
           --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 61e4505c 2>&1 \
           && echo "✓ Retry succeeded" || echo "❌ Retry failed - ticket has No Status"
       else
         echo "✓ Status set to Ready"
       fi

       # Move to top (best-effort)
       gh api graphql -f query="mutation { updateProjectV2ItemPosition(input: { projectId: \"PVT_kwHNf9fOATn4hA\", itemId: \"$ITEM_ID\" }) { item { id } } }" 2>/dev/null
     fi
     ```
   - Invalidate cache after adding tickets:
     ```bash
     bash .claude/scripts/gh-project-cache.sh invalidate
     ```

4. If new Ready tickets were created from UI issues, **loop back to Step 3** to process them instead of continuing to b-modernize research.

#### Step 6b: Pre-check

1. Check existing open suggestion tickets (REST):
   ```bash
   gh api "repos/bradyoo12/ai-dev-request/issues?state=open&labels=suggestion&per_page=50" --jq '[.[] | {number, title}]'
   ```
2. If 4+ suggestion tickets exist in Backlog, skip b-modernize entirely

#### Step 6c: Create Research Team

1. Create the team:
   ```
   TeamCreate: modernize
   ```

2. **Spawn BOTH scouts in parallel and wait** (use parallel synchronous Task - see "How to Wait for Agents" above):

   In a SINGLE message, spawn both agents with two Task calls:
   ```
   Task(subagent_type: "general-purpose", team_name: "modernize", name: "tech-scout", prompt: "...")
   Task(subagent_type: "general-purpose", team_name: "modernize", name: "competitor-scout", prompt: "...")
   ```

   **tech-scout** agent:
   - Searches for recent technologies: AI code generation, agent frameworks, .NET innovations, React ecosystem, DevOps tools
   - Evaluates relevance, effort, and impact scores
   - Reports top findings with scores

   **competitor-scout** agent:
   - Researches competitor features: Replit, Base44, Bolt.new, v0.dev, Cursor
   - Evaluates differentiation, user value, feasibility
   - Reports top findings with scores

   **WAIT**: Both Task calls execute in parallel. The message blocks until BOTH agents complete. You will receive TWO tool results (one from each agent).

#### Step 6d: Create Tickets

After collecting findings from both scouts:
1. Filter for qualifying technologies (relevance >= 3, impact >= 3, effort <= 4)
2. Deduplicate against existing tickets
3. Create suggestion tickets for qualifying findings (REST):
   ```bash
   gh api --method POST "repos/bradyoo12/ai-dev-request/issues" -f title="{title}" -f body="{body}" -f "labels[]=suggestion"
   ```
4. Add each ticket to the project and set status to **Ready** (with error handling):
   ```bash
   # Add to project
   ITEM_ID=$(gh project item-add 26 --owner bradyoo12 --url {issue_url} --format json --jq '.id')

   if [ -z "$ITEM_ID" ]; then
     echo "❌ ERROR: Failed to add suggestion ticket to project board"
   else
     # Set status to Ready with error handling
     if ! gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id "$ITEM_ID" \
          --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 61e4505c 2>&1; then

       # Failed - try switching accounts
       CURRENT_USER=$(gh api user --jq '.login' 2>/dev/null)
       echo "❌ Failed to set status (account: $CURRENT_USER), retrying..."

       [ "$CURRENT_USER" = "bradyoo12" ] && gh auth switch -u byooxbert || gh auth switch -u bradyoo12

       # Retry
       gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id "$ITEM_ID" \
         --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 61e4505c 2>&1 \
         && echo "✓ Retry succeeded" || echo "❌ Retry failed - ticket has No Status"
     else
       echo "✓ Status set to Ready"
     fi

     # Move to top (best-effort)
     gh api graphql -f query="mutation { updateProjectV2ItemPosition(input: { projectId: \"PVT_kwHNf9fOATn4hA\", itemId: \"$ITEM_ID\" }) { item { id } } }" 2>/dev/null
   fi
   ```
5. Invalidate cache after adding tickets:
   ```bash
   bash .claude/scripts/gh-project-cache.sh invalidate
   ```

#### Step 6e: Cleanup

Shut down all agents, delete the team.

### Step 7: Site Audit — Find Errors and Improvements

After modernization research, audit the live site to catch errors, bugs, and UX improvements.

#### Step 7a: Pre-check

1. Check existing open bug/improvement tickets to avoid duplicates (REST):
   ```bash
   gh api "repos/bradyoo12/ai-dev-request/issues?state=open&per_page=100" --paginate --jq '[.[] | {number, title, labels: [.labels[].name]}]'
   ```
2. Note all existing titles for dedup

#### Step 7b: Create Audit Team

1. Create the team:
   ```
   TeamCreate: site-audit
   ```

2. **Spawn BOTH agents in parallel and wait** (use parallel synchronous Task - see "How to Wait for Agents" above):

   In a SINGLE message, spawn both agents with two Task calls:
   ```
   Task(subagent_type: "general-purpose", team_name: "site-audit", name: "error-checker", prompt: "...")
   Task(subagent_type: "general-purpose", team_name: "site-audit", name: "ux-reviewer", prompt: "...")
   ```

   **error-checker** agent:
   - Use WebFetch to visit `https://icy-desert-07c08ba00.2.azurestaticapps.net/`
   - Check for:
     - HTTP errors (4xx, 5xx responses)
     - Broken links or missing assets
     - JavaScript console errors visible in the page
     - API endpoint failures (check network requests if visible)
     - Missing or broken images
     - Empty states that should have content
   - Navigate to all discoverable pages/routes from the main page
   - Report all errors found with severity (critical/major/minor)

   **ux-reviewer** agent:
   - Use WebFetch to visit `https://icy-desert-07c08ba00.2.azurestaticapps.net/`
   - Read `.claude/design.md` to understand the intended UX
   - Evaluate:
     - **Visual polish**: Layout issues, spacing, alignment, color consistency
     - **Navigation**: Is it intuitive? Are there dead ends?
     - **Responsiveness**: Does the layout suggest mobile-friendliness?
     - **Accessibility**: Missing alt text, contrast issues, keyboard navigation hints
     - **Content**: Typos, placeholder text left in, unclear labels
     - **Performance**: Slow-loading elements, large unoptimized assets
     - **Missing features**: Compare against design.md — what's described but not implemented?
   - Report all findings with impact score (1-5) and suggested improvement

   **WAIT**: Both Task calls execute in parallel. The message blocks until BOTH agents complete. You will receive TWO tool results (one from each agent).

#### Step 7c: Create Tickets

After collecting findings from both agents:

1. Filter findings:
   - **Errors** (from error-checker): Create tickets for all critical and major errors
   - **Improvements** (from ux-reviewer): Create tickets for findings with impact >= 3
2. Deduplicate against existing open tickets
3. Create max 5 tickets per cycle (REST):
   ```bash
   gh api --method POST "repos/bradyoo12/ai-dev-request/issues" -f title="{title}" -f body="{body}" -f "labels[]=bug"
   ```
   - Use label `bug` for errors found by error-checker
   - Use label `enhancement` for improvements found by ux-reviewer
4. Add tickets to the project and set status to **Ready** (with error handling):
   ```bash
   # Add to project
   ITEM_ID=$(gh project item-add 26 --owner bradyoo12 --url {issue_url} --format json --jq '.id')

   if [ -z "$ITEM_ID" ]; then
     echo "❌ ERROR: Failed to add site audit ticket to project board"
   else
     # Set status to Ready with error handling
     if ! gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id "$ITEM_ID" \
          --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 61e4505c 2>&1; then

       # Failed - try switching accounts
       CURRENT_USER=$(gh api user --jq '.login' 2>/dev/null)
       echo "❌ Failed to set status (account: $CURRENT_USER), retrying..."

       [ "$CURRENT_USER" = "bradyoo12" ] && gh auth switch -u byooxbert || gh auth switch -u bradyoo12

       # Retry
       gh project item-edit --project-id PVT_kwHNf9fOATn4hA --id "$ITEM_ID" \
         --field-id PVTSSF_lAHNf9fOATn4hM4PS3yh --single-select-option-id 61e4505c 2>&1 \
         && echo "✓ Retry succeeded" || echo "❌ Retry failed - ticket has No Status"
     else
       echo "✓ Status set to Ready"
     fi

     # Move to top (best-effort)
     gh api graphql -f query="mutation { updateProjectV2ItemPosition(input: { projectId: \"PVT_kwHNf9fOATn4hA\", itemId: \"$ITEM_ID\" }) { item { id } } }" 2>/dev/null
   fi
   ```
5. Invalidate cache after adding tickets:
   ```bash
   bash .claude/scripts/gh-project-cache.sh invalidate
   ```

#### Step 7d: Cleanup

Shut down all agents, delete the team.

### Step 8: Report Cycle Status

Log the current status of the project board:

1. Fetch the project board (uses cache if still valid from Step 5a, otherwise refreshes):
   ```bash
   PROJECT_ITEMS=$(bash .claude/scripts/gh-project-cache.sh get)
   ```

2. Calculate counts for each status:
   ```bash
   echo "$PROJECT_ITEMS" | jq '...'
   ```

3. Report:
   - Ready count (excluding `on hold`)
   - In Progress count (with and without open PRs)
   - In Review count (with and without `on hold`)
   - Done count
   - Tickets with `on hold` label
   - Backlog tickets awaiting triage

### Step 9: Check Stop Signal and Loop

**CRITICAL: Do NOT ask the user for permission to continue. Just loop automatically — unless a stop signal exists.**

1. **Check for stop signal** from `/b-start-end`:
   ```bash
   if [ -f .claude/b-start-stop-signal ]; then
     echo "Stop signal detected — finishing pipeline gracefully."
     cat .claude/b-start-stop-signal
     rm .claude/b-start-stop-signal
   fi
   ```

2. **If stop signal was found:**
   - Log: "Pipeline stopped gracefully by /b-start-end. Current cycle is complete."
   - Clean up the worktree (Step 0 cleanup)
   - **STOP. Do NOT loop. Exit the pipeline.**

3. **If NO stop signal:**
   - Log "Cycle complete. Starting next cycle in 5 seconds..."
   - Wait 5 seconds
   - **Automatically** go back to Step 1 (do not ask user, do not wait for confirmation, just loop)

**Examples of what NOT to say:**
- ❌ "Would you like me to continue?"
- ❌ "What would you prefer?"
- ❌ "Stop here - You've seen how the pipeline works"
- ❌ "Should I process the next ticket?"
- ❌ "Do you want me to continue? Or did you have a specific question about the pipeline?"
- ❌ Presenting "Next Steps" followed by asking what to do

**What to do instead:**
- ✅ Just log "Starting Cycle #N..." and go to Step 1
- ✅ Continue autonomously until Ctrl+C or stop signal
- ✅ When showing "Next Steps", immediately execute the first step without asking

## Ticket Flow Summary

```
┌──────────┐  b-ready team  ┌─────────────┐  b-progress  ┌───────────┐  b-review team  ┌──────┐
│  Ready   │ ────────────→ │ In Progress │ ──────────→ │ In Review │ ──────────────→ │ Done │
└──────────┘                └─────────────┘              └───────────┘                └──────┘
             (team: plan,        (merge PR,          (team: test-runner
              implement,          deploy to           + ai-verifier)
              unit tests,         staging)
              E2E test, PR)
     │                │                          │
     └── on hold ─────┴── on hold (test fail) ───┘
          (needs human attention)
```

## Agent Team Lifecycle

```
1. TeamCreate("ready-123")           → Creates team + task list
2. Task(team_name: "ready-123")      → Spawns agents into the team
3. SendMessage(type: "message")      → Agents coordinate via messages
4. TaskUpdate(status: "completed")   → Agents mark tasks done
5. SendMessage(type: "shutdown_request") → Orchestrator shuts down agents
6. TeamDelete()                      → Cleans up team resources
```

**IMPORTANT:** Always shut down agents and delete teams before moving to the next step. Stale teams waste resources.

## Label Meanings

| Label | Meaning |
|-------|---------|
| `on hold` | Requires human attention - do not auto-process |

## Important Notes

- **Claude Usage Limit Account Switching** — Two Claude accounts are available to maximize throughput when hitting weekly or session usage limits:
  - Account A: `brad.yoo@xbert.io`
  - Account B: `yoohoony@gmail.com`
  - When hitting ~90% of the Claude weekly limit or current session usage limit, switch to the other account:
    - If currently on `brad.yoo@xbert.io` → switch to `yoohoony@gmail.com`
    - If currently on `yoohoony@gmail.com` → switch to `brad.yoo@xbert.io`
  - If both accounts are at 90% or above, continue using the current account to 100%, then switch to the other account
  - Log the switch: "Claude usage limit approaching — switching from <current> to <other>"
- **Account Switching Strategy** — Two GitHub accounts are available to double the effective rate limit:
  - Primary: `bradyoo12` (bradyoo12@outlook.com)
  - Secondary: `byooxbert` (brad.yoo@xbert.io)
  - Switch accounts when any rate limit drops below 20% remaining
  - Check rate limits before high-volume operations (Steps 1.5, 2, 3a, 4, 5c, 6d, 7c)
  - If both accounts are rate-limited, wait until the earliest reset time
  - Each account has separate rate limits: REST (5000/hr), GraphQL (5000/hr), Search (30/min)
- **Rate Limit Optimization** — The project board is fetched in Step 1.5 and cached in `$PROJECT_ITEMS` for reuse throughout the cycle. Only re-fetch when necessary:
  - After claiming a ticket in Step 3a (to verify the claim)
  - Before Step 5a (after Step 4 made changes)
  - Before Step 8 (to get final state for reporting)
  This reduces GraphQL API calls from ~4-5 per cycle to ~2-3 per cycle, preventing rate limit exhaustion.
- **Move to top on status change** — After every `gh project item-edit` that changes a ticket's status, immediately move the item to the top of the column so it's visible on the board:
  ```bash
  gh api graphql -f query='mutation { updateProjectV2ItemPosition(input: { projectId: "PVT_kwHNf9fOATn4hA", itemId: "<item_id>" }) { item { id } } }'
  ```
  Omitting `afterId` places the item at the top of the list.
- **This command runs in an infinite loop** - orchestrates all agents until Ctrl+C
- **NEVER ask the user for permission to continue** - always proceed to the next cycle automatically. Do NOT say "Would you like me to continue?", "What would you prefer?", "Stop here", or any variation. The loop is 100% autonomous and requires zero user interaction to continue. Just keep looping.
- **ONLY processes tickets in Project 26 (AI Dev Request)** - ignores tickets in other projects
- **ONE ticket at a time** - teams parallelize WITHIN a ticket, not across tickets
- **Multi-instance safe** - Multiple b-start instances can run on the same machine (via git worktrees — see Step 0) or on different machines. The "claim" step (moving to "In Progress") MUST happen before any other work to prevent two instances from picking up the same ticket. Always verify the claim succeeded before proceeding.
- **Worktree required** - Every b-start instance MUST run Step 0 to acquire a dedicated worktree. Never run directly in the main repository checkout. Never check out the `main` branch — always use `git fetch origin && git checkout --detach origin/main`.
- Teams are created and destroyed per-step — no long-lived teams
- 5-second delay between full cycles (can be increased to 10-30s if rate limiting still occurs)
- Always check policy.md and design.md at the start of each cycle
- Tickets out of alignment get `on hold` label automatically
- Human removes `on hold` label to signal approval/readiness

## Self-Update Protocol (MANDATORY)

**After EVERY run** of this command, update this file:

### When to Update
- After encountering an error that took multiple attempts to resolve
- After discovering a missing prerequisite or undocumented dependency
- After finding a workaround for an environment or tooling issue
- After a successful run if you noticed something that could be improved

### How to Update
1. Append a new entry to the `## Lessons Learned` section below
2. Use this format:
   ```
   ### [YYYY-MM-DD] <Short Title>
   - **Problem**: What went wrong or was time-consuming
   - **Solution**: What fixed it or the workaround used
   - **Prevention**: What to do differently next time
   ```

---

## Lessons Learned

### [2026-02-07] Azure App Service auto-disables after startup crashes
- **Problem**: After deploying a backend change that caused the .NET app to crash on startup (migration bootstrap logic tried to INSERT into nonexistent `__EFMigrationsHistory` table), Azure auto-disabled the App Service entirely. Subsequent deployments then fail with "Site Disabled (CODE: 403)" and cannot deploy the fix.
- **Solution**: The code fix (ensure `__EFMigrationsHistory` table exists before INSERT, and don't crash on migration failure) was merged to main. However, someone with Azure portal access must manually re-enable the App Service before the fix can be deployed.
- **Prevention**: Always ensure migration bootstrap logic handles missing tables gracefully. Never let migration failures crash the application startup — log and continue so the app remains accessible for diagnostics. Consider adding a health check endpoint that works even when migrations fail.

### [2026-02-07] EnsureCreatedAsync vs MigrateAsync for existing databases
- **Problem**: The original code used `EnsureCreatedAsync()` which only creates a new database from scratch and cannot apply incremental schema changes. When new entities were added, the staging database (which already existed) never got the new tables, causing 500 errors on all database-dependent endpoints.
- **Solution**: Replaced with `MigrateAsync()` plus EF Core migrations. Added bootstrap logic to detect legacy databases (created by `EnsureCreatedAsync`) and insert the initial migration record so `MigrateAsync()` doesn't try to re-create existing tables.
- **Prevention**: Always use EF Core migrations from the start. Never use `EnsureCreatedAsync()` in any environment beyond initial prototyping.

### [2026-02-07] Duplicate tickets (#41 and #43) addressing same issue
- **Problem**: Tickets #41 and #43 both described the same staging 500 error from different angles. Both were in Ready status.
- **Solution**: Treated #41 as the primary ticket (migration fix) and #43 as a follow-up (startup crash fix + error handling). Both ended up being processed sequentially.
- **Prevention**: During audit, identify duplicates early and close/merge them before entering the b-ready phase.

### [2026-02-07] Azure App Service Free tier (F1) quota exceeded blocks all deployments
- **Problem**: The Free F1 App Service Plan has a 60 CPU-minutes/day quota. Repeated startup crashes burned through the quota, causing "QuotaExceeded" state and 403 "Site Disabled" on all deployment attempts. Quota resets at midnight UTC (~19 hours away).
- **Solution**: Scaled the App Service Plan from F1 (Free) to B1 (Basic, ~$13/month) using `az appservice plan update --sku B1`. This immediately lifted the quota restriction.
- **Prevention**: Use at least B1 tier for staging environments. F1 is only suitable for static sites or minimal testing.

### [2026-02-07] No database configured for Azure deployment
- **Problem**: The backend had no database connection string configured in Azure App Settings. It fell back to `Host=localhost` which doesn't work on Azure. The error handling in controllers returned default/empty data, masking the real issue (no database).
- **Solution**: Created an `ai_dev_request` database on the existing `db-bradyoo-staging` PostgreSQL Flexible Server. Configured the connection string via Azure REST API (to avoid bash escaping issues with special characters in the password).
- **Prevention**: Always verify database infrastructure exists BEFORE deploying a new service. Add connection string configuration to the deployment workflow or IaC. Consider adding a startup check that logs a clear warning if the database is unreachable.

### [2026-02-07] Bash escaping mangles special characters in Azure CLI settings
- **Problem**: Setting ConnectionStrings__DefaultConnection via "az webapp config appsettings set" mangled the password — the "!" character was escaped to "\!" by bash history expansion, even with single quotes.
- **Solution**: Used `az rest --method PUT --body @file.json` with the connection string in a JSON file to bypass all shell escaping.
- **Prevention**: For Azure App Settings containing special characters, always use `az rest` with a JSON body file instead of `az webapp config appsettings set`.

### [2026-02-14] Startup allTables check blocks MigrateAsync from creating new tables
- **Problem**: Adding new tables to the `allTables` array in `Program.cs` causes the startup partial-database detection to throw `InvalidOperationException` in staging/production before `MigrateAsync` runs. This creates a chicken-and-egg problem: migrations can't create new tables because the startup crashes when those tables don't exist.
- **Solution**: Changed the partial-database path in staging/production from throwing to logging a warning and proceeding with `MigrateAsync`. Also made migrations idempotent (IF EXISTS/IF NOT EXISTS) and made SupportController fault-tolerant for schema mismatches.
- **Prevention**: Never throw before `MigrateAsync` for missing tables — missing tables are usually just pending migrations. Always make migrations idempotent with IF EXISTS/IF NOT EXISTS guards. Make controllers fault-tolerant with try-catch for database queries that may fail due to schema differences.

### [2026-02-15] Silent GraphQL rate limit failures left 13 tickets with "No Status"
- **Problem**: 13 tickets (created Feb 13-14 by b-modernize and site-audit) were successfully added to the project board but had "No Status" instead of "Ready". The `gh project item-add` succeeded, but the subsequent `gh project item-edit` (to set status) failed silently due to GraphQL rate limit exhaustion. Bash scripts without strict error handling (`set -e`) continued execution despite the failure.
- **Solution**: Added comprehensive error handling to all ticket creation sections (Steps 4b-3, 6a, 6d, 7c): 1) Check if ITEM_ID is empty after item-add, 2) Check exit code of item-edit command, 3) On failure, switch GitHub accounts (bradyoo12 ↔ byooxbert) and retry once, 4) Log clear error messages if both attempts fail. Manually fixed the 13 affected tickets by switching to byooxbert account (which had remaining GraphQL quota) and setting their status to Ready.
- **Prevention**: Always check exit codes and capture stderr for GitHub API commands. Use the account switching pattern when rate limits are hit. Add retry logic with alternate account for all GraphQL project operations. Monitor for "No Status" tickets in Step 2 audit and auto-fix them. Consider implementing a periodic cleanup job that finds and fixes tickets with missing status.
