using System.IO.Compression;

namespace AiDevRequest.API.Services;

public interface IExportService
{
    Task<byte[]> ExportAsZipAsync(string projectPath, string projectName);
    Task<GitHubExportResult> ExportToGitHubAsync(string projectPath, string projectName, string accessToken, string? repoName = null);
}

public class ExportService : IExportService
{
    private readonly ILogger<ExportService> _logger;
    private readonly IHttpClientFactory _httpClientFactory;

    public ExportService(ILogger<ExportService> logger, IHttpClientFactory httpClientFactory)
    {
        _logger = logger;
        _httpClientFactory = httpClientFactory;
    }

    public Task<byte[]> ExportAsZipAsync(string projectPath, string projectName)
    {
        if (!Directory.Exists(projectPath))
            throw new InvalidOperationException("Project directory not found");

        using var memoryStream = new MemoryStream();
        using (var archive = new ZipArchive(memoryStream, ZipArchiveMode.Create, true))
        {
            var files = Directory.GetFiles(projectPath, "*", SearchOption.AllDirectories)
                .Where(f => !f.Contains("node_modules") && !f.Contains(".git") && !f.Contains("bin") && !f.Contains("obj"));

            foreach (var file in files)
            {
                var relativePath = Path.GetRelativePath(projectPath, file);
                var entryName = $"{projectName}/{relativePath.Replace('\\', '/')}";
                var entry = archive.CreateEntry(entryName, CompressionLevel.Optimal);

                using var entryStream = entry.Open();
                using var fileStream = File.OpenRead(file);
                fileStream.CopyTo(entryStream);
            }
        }

        return Task.FromResult(memoryStream.ToArray());
    }

    public async Task<GitHubExportResult> ExportToGitHubAsync(
        string projectPath, string projectName, string accessToken, string? repoName = null)
    {
        if (!Directory.Exists(projectPath))
            throw new InvalidOperationException("Project directory not found");

        var finalRepoName = repoName ?? projectName;

        var client = _httpClientFactory.CreateClient();
        client.DefaultRequestHeaders.Add("Authorization", $"Bearer {accessToken}");
        client.DefaultRequestHeaders.Add("User-Agent", "AiDevRequest");
        client.DefaultRequestHeaders.Add("Accept", "application/vnd.github+json");

        // Create repository
        var createRepoResponse = await client.PostAsJsonAsync(
            "https://api.github.com/user/repos",
            new
            {
                name = finalRepoName,
                description = $"Generated by AI Dev Request",
                @private = false,
                auto_init = true
            });

        if (!createRepoResponse.IsSuccessStatusCode)
        {
            var errorBody = await createRepoResponse.Content.ReadAsStringAsync();
            _logger.LogWarning("Failed to create GitHub repo: {Error}", errorBody);
            throw new InvalidOperationException($"Failed to create GitHub repository: {createRepoResponse.StatusCode}");
        }

        var repoData = await createRepoResponse.Content.ReadFromJsonAsync<GitHubRepoResponse>();
        if (repoData == null)
            throw new InvalidOperationException("Failed to parse GitHub response");

        // Get files to upload
        var files = Directory.GetFiles(projectPath, "*", SearchOption.AllDirectories)
            .Where(f => !f.Contains("node_modules") && !f.Contains(".git") && !f.Contains("bin") && !f.Contains("obj"))
            .ToList();

        var uploadedCount = 0;

        foreach (var file in files)
        {
            var relativePath = Path.GetRelativePath(projectPath, file).Replace('\\', '/');
            var content = await File.ReadAllBytesAsync(file);
            var base64Content = Convert.ToBase64String(content);

            var putResponse = await client.PutAsJsonAsync(
                $"https://api.github.com/repos/{repoData.FullName}/contents/{relativePath}",
                new
                {
                    message = $"Add {relativePath}",
                    content = base64Content
                });

            if (putResponse.IsSuccessStatusCode)
            {
                uploadedCount++;
            }
            else
            {
                _logger.LogWarning("Failed to upload {File} to GitHub: {Status}", relativePath, putResponse.StatusCode);
            }
        }

        _logger.LogInformation("Exported {Count}/{Total} files to GitHub: {Repo}", uploadedCount, files.Count, repoData.FullName);

        return new GitHubExportResult
        {
            RepoUrl = repoData.HtmlUrl,
            RepoFullName = repoData.FullName,
            FilesUploaded = uploadedCount,
            TotalFiles = files.Count
        };
    }
}

public class GitHubExportResult
{
    public string RepoUrl { get; set; } = "";
    public string RepoFullName { get; set; } = "";
    public int FilesUploaded { get; set; }
    public int TotalFiles { get; set; }
}

public class GitHubRepoResponse
{
    public string FullName { get; set; } = "";
    public string HtmlUrl { get; set; } = "";
    public string CloneUrl { get; set; } = "";
}
