using System.Text.Json;
using AiDevRequest.API.Data;
using AiDevRequest.API.Entities;
using Anthropic.SDK;
using Anthropic.SDK.Messaging;
using Microsoft.EntityFrameworkCore;

namespace AiDevRequest.API.Services;

public interface IResultAggregationService
{
    Task<AggregationResult> AggregateResultsAsync(int orchestrationId);
    Task<List<MergeConflict>> DetectConflictsAsync(int orchestrationId);
    Task<MergeConflict> ResolveConflictAsync(int conflictId, bool autoResolve);
}

public class ResultAggregationService : IResultAggregationService
{
    private readonly AiDevRequestDbContext _context;
    private readonly AnthropicClient _client;
    private readonly ILogger<ResultAggregationService> _logger;

    public ResultAggregationService(
        AiDevRequestDbContext context,
        IConfiguration configuration,
        ILogger<ResultAggregationService> logger)
    {
        _context = context;
        _logger = logger;

        var apiKey = configuration["Anthropic:ApiKey"]
            ?? Environment.GetEnvironmentVariable("ANTHROPIC_API_KEY")
            ?? throw new InvalidOperationException("Anthropic API key not configured");

        _client = new AnthropicClient(apiKey);
    }

    public async Task<AggregationResult> AggregateResultsAsync(int orchestrationId)
    {
        _logger.LogInformation("Aggregating results for orchestration {OrchestrationId}", orchestrationId);

        var orchestration = await _context.ParallelOrchestrations
            .Include(o => o.Tasks)
            .FirstOrDefaultAsync(o => o.Id == orchestrationId);

        if (orchestration == null)
        {
            throw new InvalidOperationException($"Orchestration {orchestrationId} not found");
        }

        var result = new AggregationResult
        {
            OrchestrationId = orchestrationId,
            AllFiles = new Dictionary<string, MergedFileContent>()
        };

        // Collect all generated files from completed tasks
        foreach (var task in orchestration.Tasks.Where(t => t.Status == "completed"))
        {
            if (string.IsNullOrEmpty(task.OutputJson)) continue;

            try
            {
                var output = JsonSerializer.Deserialize<CodeGenerationOutput>(task.OutputJson);
                if (output == null || output.GeneratedFiles == null) continue;

                foreach (var file in output.GeneratedFiles)
                {
                    if (!result.AllFiles.ContainsKey(file.Path))
                    {
                        result.AllFiles[file.Path] = new MergedFileContent
                        {
                            Path = file.Path,
                            Content = file.Content,
                            Language = file.Language,
                            Contributors = new List<string> { task.TaskType }
                        };
                    }
                    else
                    {
                        // File conflict - multiple agents generated the same file
                        result.AllFiles[file.Path].Contributors.Add(task.TaskType);
                        result.Conflicts.Add(new MergeConflict
                        {
                            FilePath = file.Path,
                            ConflictType = "file_overlap",
                            Description = $"File '{file.Path}' was generated by multiple agents: {string.Join(", ", result.AllFiles[file.Path].Contributors)}",
                            TaskIds = orchestration.Tasks
                                .Where(t => t.Status == "completed" && t.OutputJson.Contains(file.Path))
                                .Select(t => t.Id)
                                .ToList(),
                            Severity = "high",
                            Status = "unresolved"
                        });
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to parse output for task {TaskId}", task.Id);
            }
        }

        // Detect import conflicts (e.g., backend and frontend disagreeing on API contract)
        await DetectImportConflictsAsync(result, orchestration);

        // Detect API contract mismatches
        await DetectApiContractMismatchesAsync(result, orchestration);

        // Save conflicts to orchestration
        if (result.Conflicts.Count > 0)
        {
            orchestration.MergeConflictsJson = JsonSerializer.Serialize(result.Conflicts);
            await _context.SaveChangesAsync();
        }

        _logger.LogInformation("Aggregation complete: {FileCount} files, {ConflictCount} conflicts",
            result.AllFiles.Count, result.Conflicts.Count);

        return result;
    }

    private async Task DetectImportConflictsAsync(AggregationResult result, ParallelOrchestration orchestration)
    {
        // Check for conflicting imports/dependencies
        // E.g., backend exports TypeScript interface but frontend imports different type

        var backendTask = orchestration.Tasks.FirstOrDefault(t => t.TaskType == "backend" && t.Status == "completed");
        var frontendTask = orchestration.Tasks.FirstOrDefault(t => t.TaskType == "frontend" && t.Status == "completed");

        if (backendTask == null || frontendTask == null) return;

        try
        {
            var backendOutput = JsonSerializer.Deserialize<CodeGenerationOutput>(backendTask.OutputJson ?? "{}");
            var frontendOutput = JsonSerializer.Deserialize<CodeGenerationOutput>(frontendTask.OutputJson ?? "{}");

            if (backendOutput == null || frontendOutput == null) return;

            // Simple heuristic: check if frontend imports from API but API doesn't export
            foreach (var frontendFile in frontendOutput.GeneratedFiles)
            {
                if (frontendFile.Content.Contains("import") && frontendFile.Content.Contains("/api/"))
                {
                    // Frontend is importing from API - verify exports exist
                    var apiExports = backendOutput.GeneratedFiles
                        .Where(f => f.Path.Contains("Controller") || f.Path.Contains("Dto"))
                        .SelectMany(f => ExtractExportedTypes(f.Content))
                        .ToHashSet();

                    var frontendImports = ExtractImportedTypes(frontendFile.Content);

                    var missingExports = frontendImports.Except(apiExports).ToList();

                    if (missingExports.Count > 0)
                    {
                        result.Conflicts.Add(new MergeConflict
                        {
                            FilePath = frontendFile.Path,
                            ConflictType = "import_mismatch",
                            Description = $"Frontend imports types that backend doesn't export: {string.Join(", ", missingExports)}",
                            TaskIds = new List<int> { backendTask.Id, frontendTask.Id },
                            Severity = "high",
                            Status = "unresolved"
                        });
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to detect import conflicts");
        }

        await Task.CompletedTask;
    }

    private async Task DetectApiContractMismatchesAsync(AggregationResult result, ParallelOrchestration orchestration)
    {
        // Check if frontend expects endpoints that backend doesn't provide

        var backendTask = orchestration.Tasks.FirstOrDefault(t => t.TaskType == "backend" && t.Status == "completed");
        var frontendTask = orchestration.Tasks.FirstOrDefault(t => t.TaskType == "frontend" && t.Status == "completed");

        if (backendTask == null || frontendTask == null) return;

        try
        {
            var backendOutput = JsonSerializer.Deserialize<CodeGenerationOutput>(backendTask.OutputJson ?? "{}");
            var frontendOutput = JsonSerializer.Deserialize<CodeGenerationOutput>(frontendTask.OutputJson ?? "{}");

            if (backendOutput == null || frontendOutput == null) return;

            // Extract API endpoints from backend controllers
            var backendEndpoints = backendOutput.GeneratedFiles
                .Where(f => f.Path.Contains("Controller"))
                .SelectMany(f => ExtractApiEndpoints(f.Content))
                .ToHashSet();

            // Extract API calls from frontend
            var frontendApiCalls = frontendOutput.GeneratedFiles
                .SelectMany(f => ExtractApiCalls(f.Content))
                .ToHashSet();

            // Find mismatches
            var missingEndpoints = frontendApiCalls.Except(backendEndpoints).ToList();

            if (missingEndpoints.Count > 0)
            {
                result.Conflicts.Add(new MergeConflict
                {
                    FilePath = "API Contract",
                    ConflictType = "api_contract_mismatch",
                    Description = $"Frontend calls endpoints that backend doesn't provide: {string.Join(", ", missingEndpoints)}",
                    TaskIds = new List<int> { backendTask.Id, frontendTask.Id },
                    Severity = "critical",
                    Status = "unresolved"
                });
            }
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to detect API contract mismatches");
        }

        await Task.CompletedTask;
    }

    private List<string> ExtractExportedTypes(string code)
    {
        var types = new List<string>();

        // Simple regex to find exported types (C# classes, interfaces, records)
        var classMatches = System.Text.RegularExpressions.Regex.Matches(code, @"public\s+(class|interface|record)\s+(\w+)");
        foreach (System.Text.RegularExpressions.Match match in classMatches)
        {
            if (match.Groups.Count > 2)
            {
                types.Add(match.Groups[2].Value);
            }
        }

        return types;
    }

    private List<string> ExtractImportedTypes(string code)
    {
        var types = new List<string>();

        // Simple extraction of imported types from TypeScript/JavaScript
        var importMatches = System.Text.RegularExpressions.Regex.Matches(code, @"import\s+\{([^}]+)\}");
        foreach (System.Text.RegularExpressions.Match match in importMatches)
        {
            if (match.Groups.Count > 1)
            {
                var importedTypes = match.Groups[1].Value.Split(',')
                    .Select(t => t.Trim())
                    .Where(t => !string.IsNullOrEmpty(t));
                types.AddRange(importedTypes);
            }
        }

        return types;
    }

    private List<string> ExtractApiEndpoints(string code)
    {
        var endpoints = new List<string>();

        // Extract HTTP method attributes and route patterns
        var matches = System.Text.RegularExpressions.Regex.Matches(
            code,
            @"\[Http(Get|Post|Put|Delete|Patch)\(""([^""]*)""\)\]",
            System.Text.RegularExpressions.RegexOptions.IgnoreCase
        );

        foreach (System.Text.RegularExpressions.Match match in matches)
        {
            if (match.Groups.Count > 2)
            {
                var method = match.Groups[1].Value.ToUpperInvariant();
                var route = match.Groups[2].Value;
                endpoints.Add($"{method} {route}");
            }
        }

        return endpoints;
    }

    private List<string> ExtractApiCalls(string code)
    {
        var calls = new List<string>();

        // Extract fetch/axios calls
        var matches = System.Text.RegularExpressions.Regex.Matches(
            code,
            @"(fetch|axios\.(get|post|put|delete|patch))\s*\(\s*['""]([^'""]+)['""]"
        );

        foreach (System.Text.RegularExpressions.Match match in matches)
        {
            if (match.Groups.Count > 3)
            {
                var method = match.Groups[2].Success ? match.Groups[2].Value.ToUpperInvariant() : "GET";
                var route = match.Groups[3].Value;
                calls.Add($"{method} {route}");
            }
        }

        return calls;
    }

    public async Task<List<MergeConflict>> DetectConflictsAsync(int orchestrationId)
    {
        _logger.LogInformation("Detecting conflicts for orchestration {OrchestrationId}", orchestrationId);

        var orchestration = await _context.ParallelOrchestrations.FindAsync(orchestrationId);
        if (orchestration == null || string.IsNullOrEmpty(orchestration.MergeConflictsJson))
        {
            return new List<MergeConflict>();
        }

        var conflicts = JsonSerializer.Deserialize<List<MergeConflict>>(orchestration.MergeConflictsJson);
        return conflicts ?? new List<MergeConflict>();
    }

    public async Task<MergeConflict> ResolveConflictAsync(int conflictId, bool autoResolve)
    {
        _logger.LogInformation("Resolving conflict {ConflictId} (auto={AutoResolve})", conflictId, autoResolve);

        // In a real implementation, this would:
        // 1. Load the conflict details
        // 2. If autoResolve, use Claude to generate a merged version
        // 3. Update the conflict status
        // 4. Save the resolution

        // For now, return a placeholder
        var conflict = new MergeConflict
        {
            Id = conflictId,
            Status = "resolved",
            Resolution = autoResolve ? "Auto-resolved using AI" : "Manually resolved"
        };

        if (autoResolve)
        {
            // Use Claude to resolve the conflict
            var resolutionPrompt = @"You are a code merge expert. Resolve the following conflict by merging the conflicting code sections:

[Conflict details would be inserted here]

Provide a clean, merged version that preserves the intent of both contributions.";

            try
            {
                var messages = new List<Message>
                {
                    new Message(RoleType.User, resolutionPrompt)
                };

                var parameters = new MessageParameters
                {
                    Messages = messages,
                    MaxTokens = 4096,
                    Model = "claude-sonnet-4-20250514",
                    Stream = false,
                    Temperature = 0.5m
                };

                var response = await _client.Messages.GetClaudeMessageAsync(parameters);
                conflict.Resolution = response.Content.FirstOrDefault()?.ToString() ?? "Failed to resolve";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to auto-resolve conflict {ConflictId}", conflictId);
                conflict.Status = "failed";
                conflict.Resolution = $"Auto-resolution failed: {ex.Message}";
            }
        }

        return conflict;
    }
}

// DTOs
public class AggregationResult
{
    public int OrchestrationId { get; set; }
    public Dictionary<string, MergedFileContent> AllFiles { get; set; } = new();
    public List<MergeConflict> Conflicts { get; set; } = new();
}

public class MergedFileContent
{
    public string Path { get; set; } = "";
    public string Content { get; set; } = "";
    public string Language { get; set; } = "";
    public List<string> Contributors { get; set; } = new();
}

public class MergeConflict
{
    public int Id { get; set; }
    public string FilePath { get; set; } = "";
    public string ConflictType { get; set; } = ""; // file_overlap, import_mismatch, api_contract_mismatch
    public string Description { get; set; } = "";
    public List<int> TaskIds { get; set; } = new();
    public string Severity { get; set; } = ""; // critical, high, medium, low
    public string Status { get; set; } = ""; // unresolved, resolved, failed
    public string? Resolution { get; set; }
}
